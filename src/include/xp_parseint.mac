.nlist

;This file is part of Xperiment68k
;Copyright (C) 2025 TcbnErik
;
;This program is free software: you can redistribute it and/or modify
;it under the terms of the GNU General Public License as published by
;the Free Software Foundation, either version 3 of the License, or
;(at your option) any later version.
;
;This program is distributed in the hope that it will be useful,
;but WITHOUT ANY WARRANTY; without even the implied warranty of
;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;GNU General Public License for more details.
;
;You should have received a copy of the GNU General Public License
;along with this program.  If not, see <https://www.gnu.org/licenses/>.

.ifndef xp_parseint_mac
        xp_parseint_mac:=1


;(マクロ内部で使用) 文字列を数値化する際のエラー処理
_DEFINE_PARSEINTERROR: .macro
  _DEFINE_PARSEINTERROR: .macro
  .endm

_ParseIntError:
  lea (@strNumberError,pc),a0
  bra _Fatal

.data
@strNumberError: .dc.b '数値の指定が正しくありません。',CR,LF,0
.text

  _DEFINE_FATAL
.endm


;(マクロ内部で使用) 文字列を数値化(ロングワードサイズ)
_DEFINE_PARSEINT: .macro
  _DEFINE_PARSEINT: .macro
  .endm

_ParseInt:
  movem.l d1-d2/a1,-(sp)
  cmpi.b #'-',(a0)
  bne 1f
    addq.l #1,a0
    bsr @ParseIntCore
    neg.l d0
    bmi @f
    beq @f
    bra _ParseIntError  ;0または負数として表現できない
  1:
    bsr @ParseIntCore
  @@:
  subq.l #1,a0
  cmpa.l a0,a1
  movem.l (sp)+,d1-d2/a1
  beq _ParseIntError  ;数字が一つもなかった
  rts

@ParseIntCore:
  moveq #0,d0
  moveq #'0',d2

  moveq #0,d1
  move.b (a0)+,d1
  cmpi.b #'$',d1
  beq @ParseHex
  cmpi.b #'%',d1
  beq @ParseBinary
  cmp.b d2,d1
  bne @ParseDecimal

  move.b (a0)+,d1
  cmpi.b #'x',d1
  beq @ParseHex  ;'0x'
  cmpi.b #'b',d1
  beq @ParseBinary  ;'0b'

  subq.l #1,a0  ;それ以外で'0'から始まる場合
  bra @ParseDecimal

@ParseDecimal:
  subq.l #1,a0
  lea (a0),a1
  bra 8f
  2:
    cmpi.l #429496729,d0  ;$ffff_ffff/10
    bhi _ParseIntError  ;10倍するとオーバーフローしてしまう

    move.l d0,d2
    lsl.l #2,d0  ;4n
    add.l d2,d0  ;5n
    add.l d0,d0  ;10n
    add.l d1,d0  ;10n + m
    bcs _ParseIntError
  8:
  move.b (a0)+,d1
  subi.b #'0',d1
  cmpi.b #9,d1
  bls 2b
  rts

@ParseHex:
  lea (a0),a1
  bra 8f
  1:
    subi.b #'a'-10,d1  ;'a'..'f' -> 10..15
  2:
    cmpi.l #$ffff_ffff>>4,d0
    bhi _ParseIntError  ;16倍するとオーバーフローしてしまう

    lsl.l #4,d0
    or.b d1,d0
  8:
  move.b (a0)+,d1
  sub.b d2,d1  ;subi.b #'0',d1
  cmpi.b #9,d1
  bls 2b  ;'0'..'9' -> 0..9

  add.b d2,d1
  ori.b #$20,d1  ;小文字化
  cmpi.b #'a',d1
  bcs @f
    cmpi.b #'f',d1
    bls 1b
  @@:
  rts

@ParseBinary:
  lea (a0),a1
  bra 8f
  2:
    addx.l d0,d0
    bcs _ParseIntError
  8:
  move.b (a0)+,d1
  sub.b d2,d1  ;subi.b #'0',d1
  lsr.b #1,d1
  beq 2b

  subq.b #('9'-'0')>>1,d1
  bls _ParseIntError  ;0と1の後ろにほかの数字が続いていたらエラーにする
  rts

  _DEFINE_PARSEINTERROR
.endm


;文字列を数値化(ロングワードサイズ)
DEFINE_PARSEINT: .macro label
label: .equ _ParseInt

  _DEFINE_PARSEINT
.endm


;(マクロ内部で使用) 文字列を数値化(ワードサイズ)
_DEFINE_PARSEINTWORD: .macro
  _DEFINE_PARSEINTWORD: .macro
  .endm

_ParseIntWord:
  bsr _ParseInt
  cmpi.l #$0000_ffff,d0
  bgt _ParseIntError
  cmpi.l #$ffff_8000,d0
  blt _ParseIntError
  rts

  _DEFINE_PARSEINT
.endm


;文字列を数値化(ワードサイズ)
DEFINE_PARSEINTWORD: .macro label
label: .equ _ParseIntWord

  _DEFINE_PARSEINTWORD
.endm


;(マクロ内部で使用) 文字列を数値化(バイトサイズ)
_DEFINE_PARSEINTBYTE: .macro
  _DEFINE_PARSEINTBYTE: .macro
  .endm

_ParseIntByte:
  bsr _ParseInt
  cmpi.l #$0000_00ff,d0
  bgt _ParseIntError
  cmpi.l #$ffff_ff80,d0
  blt _ParseIntError
  rts

  _DEFINE_PARSEINT
.endm


;文字列を数値化(バイトサイズ)
DEFINE_PARSEINTBYTE: .macro label
label: .equ _ParseIntByte

  _DEFINE_PARSEINTBYTE
.endm


.endif
.list
