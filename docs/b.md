# B

## beep_adpcmout
システムに登録されているビープ音を、`IOCS _ADPCMOUT`で再生します。


## beep_mpcm
システムに登録されているビープ音を、MPCM.Xで効果音として再生します(`$10xx M_EFCT_OUT`)。

> [!WARNING]
> リターンキーによる全チャンネル再生は大きな音が出るので注意してください。


## beep_zmsc3
システムに登録されているビープ音を、ZMSC3.Xで効果音として再生します(`$13 ZM_SE_ADPCM1`)。

> [!WARNING]
> リターンキーによる全チャンネル再生は大きな音が出るので注意してください。


## bg1pr2th
特に機能はない2個のスレッドを作成して常駐終了します(それぞれの名前は`bgthread1`、`bgthread2`)。
どちらかのスレッドを[bgkill](#bgkill)で指定すれば、両方のスレッドを削除して常駐解除します。


## bgexec
コマンドライン引数で指定したファイルと引数を実行するように、`DOS _SEND_PR`で`bgexecd`スレッドに
コマンドを送ります。
事前に[bgexecd](#bgexecd)を常駐しておく必要があります。


## bgexecd
バックグラウンドでファイルを実行する機能を持つ、`bgexecd`という名前のスレッドを
作成して常駐終了します。
[bgexec](#bgexec)を使って指定したファイルを実行することができます。
常駐解除は[bgkill](#bgkill)を使います。

独自の環境変数を持たず親の環境をそのまま使います(手抜き)。


## bgkill
コマンドライン引数で指定した名前のスレッドに、`DOS _SEND_PR`で終了要求コマンド(`$fff9`)を
送信します。送信先のスレッドが終了要求コマンドに対応していない場合は意味がありません。


## bglivingdead
スレッドを登録したプロセスが常駐終了するより前に、そのスレッドが`DOS _KILL_PR`で終了すると、
Human68kが異常動作する不具合(Human68k v3.02)を検証します。

実行後は再起動してください。

> [!WARNING]
> 実験用に用意したシステムでのみ実行してください。  
> ※普段使っているシステムでは実行しないこと！


## bgsprocd
[bgexecd](#bgexecd)とほぼ同じ(スレッド名も`bgexecd`)ですが、メモリの上位から256KBの
メモリブロックを確保し、`DOS _S_PROCESS`でサブのメモリ管理として設定します。
[bgexec](#bgexec)で実行するプロセスはそのメモリブロック内でメモリが確保されます。

[bgkill](#bgkill)で終了要求を送信すると、`DOS _S_MFREE`でサブのメモリ管理の解放を指定して
常駐解除します。Human68kの`_S_MFREE`の不具合の不具合の影響を受けるので注意してください
(サブのメモリ管理内で常駐終了しているプロセスがあるとメモリが破壊されます)。


## bgsprocess
メモリの上位から512KBのメモリを確保し、コマンドライン引数で指定した名前のスレッドに対し
`DOS _S_PROCESS`でサブのメモリ管理として設定します。
`DOS _KEEPPR`による常駐終了ではなく`DOS _EXIT`で通常の終了を行いますが、その影響は未検証です。


## bgthreadid
コマンドライン引数で指定した名前のスレッドのスレッドIDを表示します。
引数省略時は現在のスレッドIDを表示します。


## bgwakeup
コマンドライン引数で指定した名前のスレッドに、`DOS _SEND_PR`で強制スリープ解除コマンド
(`$fffb`)を送信します。


## bgzombie
バックグラウンドタスクで子プロセスを実行し、終了して戻ってきた直後に`DOS _KILL_PR`を実行すると
プロセスは削除されるがスレッド管理情報が削除されず、不正なスレッド実行が行われてしまう不具合
(Human68k v3.02)を検証します。  

実行後は再起動してください。

> [!WARNING]
> 実験用に用意したシステムでのみ実行してください。  
> ※普段使っているシステムでは実行しないこと！


## bitsns
`IOCS _BITSNS`を実行してキーの押し下げ状態を表示します。  
マウスのボタンを押すと終了します。

IOCSワークに保存されているキー状態をIOCSコール経由で取得しているだけなので、
実際にキーボードから送られたスキャンコードがそのまま表示されるわけではありません。  
キーボードから送信されるスキャンコードをそのまま得たい場合は、[keyscan](#keyscan)を使用してください。


### bindno
`DOS _EXEC (MD=5;bindno)`でオーバーレイXファイルのモジュール番号を取得し、結果を表示します。  
一つ目のコマンドライン引数でオーバーレイXファイルのファイル名を、
二つ目の引数でモジュールのファイル名を指定します。

Human68k内部で引数で指定したモジュールのファイル名の拡張子の1バイト目が`X`に変更されるため、
以下の挙動になります。
* モジュールの拡張子`.X`は省略できます。
* 拡張子の1バイト目が`X`以外のモジュールを取得できません。
* TwentyOne +Cのとき拡張子が小文字の`x`のモジュールを取得できません。

使用例: `bindno COMMAND.X COMMANDO.x`


## bkeyinpd3
`IOCS _B_EKYINP`を実行し`d0`と`d3`レジスタの値を表示します。  
ESCキーを押すと終了します。


## bputmes_cur
`IOCS _B_CUROFF`でカーソル点滅を一時停止せずにカーソル描画中に`IOCS _B_PUTMES`を呼び出すと、
カーソルの反転描画が残ってしまう挙動を検証します。

これを防ぐには、`_B_PUTMES`の前後で`_B_CUROFF`と`_B_CURON`を呼び出します。


## buserr_2w
ユーザーモードにおいて、メインメモリ末尾-2のアドレスからロングワードサイズで読み込みを行い
バスエラーを発生させます。  
M68000は16ビットバスなので、メインメモリの容量が`$00Y0_0000`のとき以下のような挙動になります。
1. メインメモリ末尾-2(`$00Xf_fffe`)から1ワード読み込む → 成功
2. メモリ未実装アドレスまたはGVRAM(`$00Y0_0000`)から1ワード読み込む → バスエラー発生

ただし拡張エリアセットやMMUによりメインメモリの末尾付近がスーパーバイザ保護されている場合は、
1.の時点でバスエラーが発生します。
