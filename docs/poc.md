# Proof of Concept

## bglivingdead
スレッドを登録したプロセスが常駐終了するより前に、そのスレッドが`DOS _KILL_PR`で終了すると、
Human68kが異常動作する不具合(Human68k v3.02)を検証します。

実行後は再起動してください。

> [!WARNING]
> 実験用に用意したシステムでのみ実行してください。  
> ※普段使っているシステムでは実行しないこと！


## bgzombie
バックグラウンドタスクで子プロセスを実行し、終了して戻ってきた直後に`DOS _KILL_PR`を実行すると
プロセスは削除されるがスレッド管理情報が削除されず、不正なスレッド実行が行われてしまう不具合
(Human68k v3.02)を検証します。  

実行後は再起動してください。

> [!WARNING]
> 実験用に用意したシステムでのみ実行してください。  
> ※普段使っているシステムでは実行しないこと！


## bkeyinpd3
`IOCS _B_EKYINP`を実行し`d0`と`d3`レジスタの値を表示します。  
ESCキーを押すと終了します。


## chxdummy
※SRAMの内容を破壊するので、破壊しても構わないエミュレータ上でのみ試してください。

Xellent30用インストーラch30inst.x、chxinst.xは、SRAMに既に別のプログラムが組み込まれていても
空き領域を検索し共存してインストールすることができます。
その機能を試すためのツールです。

ch30*.sysがインストールできる最小限の領域だけ残して、何もしないダミープログラムを組み込みます。

使用法:
```
chxdummy ch30_omake.sys
chxinst ch30_omake.sys
```


## conctrl_so
`DOS _CONCTRL`で引数が少ないファンクションを呼び出した場合に、スタック上に積まれた引数より
多くのメモリを読み込んでしまう挙動(Human68k v3.02)を検証します。  

メインメモリ容量を11MB以下にし、メインメモリの高位アドレスにメモリブロックやRAMDISK
などのバッファがない状態で実行してください。バスエラーが発生します。

コマンドライン引数で動作モードを指定できます(無指定時は`c`)。
* `f` ... MD = 14
* `w` ... MD = 16
* `c` ... MD = 17

`f`と`w`はHIOCS.Xでも問題が再現するものとして選定しました(元の処理ルーチンに飛ぶため)。
MD = 15も元の処理ルーチンに飛びますが、追加の引数が2ワードあるため該当しません。
`c`については元の処理ルーチンには飛ばずIOCSコールを使うため再現しません。

なおエミュレータによっては、バスエラーではなくアドレスエラーが発生するものがあります
(関連: [buserr_2w](b.md#buserr_2w))。


## env_sbo
`DOS _GETENV`で環境変数名が長すぎる場合に、スタック上に確保されたバッファの範囲外に
書き込んでしまう挙動(Human68k v3.02)を検証します。  
なにかコマンドライン引数を指定すると、`DOS _SETENV`で環境変数名と設定する文字列が
長すぎる場合の同様の挙動を検証します。

DOSコール内部のサブルーチンにある`rts`命令で読み込まれるリターンアドレスの部分を、
用意した乗っ取りルーチンのアドレスで上書きさせることで、リターンする代わりに
そのルーチンを呼び出すように細工しています。

> [!WARNING]
> プログラムが終了しないためリセットする必要があります。  
> コピーバックのディスクキャッシュなどはあらかじめ解除してください。  
> 実験用に用意したシステムでのみ実行してください。  
> ※普段使っているシステムでは実行しないこと！

プログラムを起動すると確認プロンプトが表示されるので、
`yes`と入力してリターンキーで確定すると実行されます。


## fatchk_bof
`DOS _FATCHK`でバッファの範囲外に書き込んでしまう不具合(Human68k v3.02)を検証します。


## incdir_test
STUDIO KAMADAさんで解説されているHuman68kの
「[サブディレクトリ内のファイルが増えたときファイルなどが壊れることがある](https://stdkmd.net/bugsx68k/#human_subdir)」
不具合について、再現手順の(2)～(6)を実行します。  
あらかじめ再現手順(0)～(1)を実行後、カレントドライブをMOに変更にしてからこのプログラムを実行します。

なお手元の環境(Human68k v3.02、TwentyOne.x v1.36c)にて、このプログラムでは
「サブディレクトリ内の '.' と '..' のエントリが二重に記録される」
症状は再現できませんでした。

> [!WARNING]
> 実験用に用意したシステムでのみ実行してください。  
> ※普段使っているシステムでは実行しないこと！


## nameck_bof
`DOS _NAMECK`でバッファの範囲外に書き込んでしまう不具合(Human68k v3.02)を検証します。

コマンドライン引数で指定したファイル名(パス名)を`DOS _NAMECK`で展開し、結果を表示します。
省略した場合は指定できる最大の長さ(89バイト)のダミーパス名を使用します。

バッファの直後のメモリが破壊された場合は16進数ダンプを表示します
(バイト値が`0xff`の場合は`__`となります)。


## namests_bof
`DOS _NAMESTS`でバッファの範囲外に書き込んでしまう不具合(Human68k v3.02)を検証します。

コマンドライン引数で指定したファイル名(パス名)を`DOS _NAMESTS`で展開し、結果を表示します。
省略した場合は指定できる最大の長さ(89バイト)のダミーパス名を使用します。

バッファの直後のメモリが破壊された場合は16進数ダンプを表示します
(バイト値が`0xff`の場合は`__`となります)。


## ns_sbo
ファイル入出力のDOSコールの一部に、システムスタック上にバッファを確保して
`DOS _NAMESTS`の内部ルーチンを呼び出すものがありますが、
そのルーチンがバッファの範囲外に書き込んでしまう不具合(Human68k v3.02)を検証します。  
スタック破壊の結果、アドレスエラーなどが発生します。

コマンドライン引数で検証するDOSコールの種類を指定します。  
引数を省略して実行すると使用できるDOSコールを表示します。

> [!WARNING]
> プログラムを正常に終了できないためリセットする必要があります。  
> コピーバックのディスクキャッシュなどはあらかじめ解除してください。  
> 実験用に用意したシステムでのみ実行してください。  
> ※普段使っているシステムでは実行しないこと！

プログラムを起動すると確認プロンプトが表示されるので、
`yes`と入力してリターンキーで確定すると実行されます。


## pathchk_bof1
`DOS _EXEC (md=2;pathchk)`でファイル名に長い文字列を渡すとバッファオーバーフロー
を起こす不具合(Human68k v3.02)を検証します。

コマンドライン文字列に意図しない文字列が書き込まれます。

> [!WARNING]
> プログラムを正常に終了できずリセットしなければならなくなる恐れがあります。  
> コピーバックのディスクキャッシュなどはあらかじめ解除してください。  
> 実験用に用意したシステムでのみ実行してください。  
> ※普段使っているシステムでは実行しないこと！


## pathchk_bof2
`DOS _EXEC (md=2;pathchk)`でファイル名に長い文字列を渡すとバッファオーバーフロー
を起こす不具合(Human68k v3.02)を検証します。

[pathchk_bof1](#pathchk_bof1)よりさらに長い文字列を渡すことでシステムスタックを破壊し、
回復できないアドレスエラーなどが発生します。

> [!WARNING]
> プログラムを正常に終了できないためリセットする必要があります。  
> コピーバックのディスクキャッシュなどはあらかじめ解除してください。  
> 実験用に用意したシステムでのみ実行してください。  
> ※普段使っているシステムでは実行しないこと！


## zerounit.sys
ディスクを破壊する可能性があるため、試す場合は独立したエミュレータ環境でのみ使用して下さい。

ブロックデバイスが初期化時にユニット数=0を返してはいけないことを検証します。  
これは本来あってはならない動作であり、Human68kがDPBを65536個作成してしまいます。

リモートドライブのデバイスドライバとして作られており、CONFIG.SYSの`DEVICE =`
行で組み込むことができますが、初期化するとユニット数=0を返す以外の機能はありません。

