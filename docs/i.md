# I

## incdir_test
STUDIO KAMADAさんで解説されているHuman68kの
「[サブディレクトリ内のファイルが増えたときファイルなどが壊れることがある](https://stdkmd.net/bugsx68k/#human_subdir)」
不具合について、再現手順の(2)～(6)を実行します。  
あらかじめ再現手順(0)～(1)を実行後、カレントドライブをMOに変更にしてからこのプログラムを実行します。

なお手元の環境(Human68k v3.02、TwentyOne.x v1.36c)にて、このプログラムでは
「サブディレクトリ内の '.' と '..' のエントリが二重に記録される」
症状は再現できませんでした。

> [!WARNING]
> 実験用に用意したシステムでのみ実行してください。  
> ※普段使っているシステムでは実行しないこと！


## iocs_datebcd
コマンドライン引数で指定したバイナリ形式の日付データ(16進数、省略時は現在日)を、
`IOCS _DATEBCD`でBCD形式に変換して表示します。


## iocs_datebin
コマンドライン引数で指定したBCD形式の日付データ(16進数、省略時は現在日)を、
`IOCS _DATEBIN`でバイナリ形式に変換して表示します。


## iocs_dateget
`IOCS _DATEGET`で日付を取得して表示します。


## iocs_dateset
コマンドライン引数で指定したBCD形式の日付データ(16進数)を、`IOCS _DATESET`でRTCに設定します。
戻り値は常に0になります。


## iocs_ontime
`IOCS _ONTIME`で取得した起動後の経過時間(1/100秒単位)を表示します。  
なにかコマンドライン引数を指定すると経過日数を表示します。


## iocs_timebcd
コマンドライン引数で指定したバイナリ形式の時刻データ(16進数、省略時は現在時)を、
`IOCS _TIMEBCD`でBCD形式に変換して表示します。


## iocs_timebin
コマンドライン引数で指定したBCD形式の時刻データ(16進数、省略時は現在時)を、
`IOCS _TIMEBIN`でバイナリ形式に変換して表示します。


## iocs_timeget
`IOCS _TIMEGET`で時刻を取得して表示します。


## iocs_timeset
コマンドライン引数で指定したBCD形式の時刻データ(16進数)を、`IOCS _TIMESET`でRTCに設定します。
戻り値は常に0になります。


## iocs_txfill
`IOCS _TXFILL`のサンプルです。


## iocs_txyline
`IOCS _TXYLINE`のサンプルです。


## iocs_txrascpy
`IOCS _TXRASCPY`によるラスタコピーを行います。  
使用法: iocs_txrascpy コピー元 コピー先 ラスタ数 移動方向(0:下,-1:上) テキストプレーン  
移動方向、テキストプレーンは省略できます(省略時は0:下、%0011となります)。

X68000をクロックアップ改造しているとラスタコピーに失敗して画面が乱れることがあります。  
IOCS.XやHIOCS.Xを組み込んでいるとコンソールのスクロールに内部のルーチンを使うほか、
アプリケーションによっては独自のラスタコピールーチンを持っているため、
`IOCS _TXRASCPY`が呼び出される機会がなく後から問題に気づくこともしばしばあるようです。

画面が乱れる場合は、`IOCS _TXRASCPY`を高クロック対応ルーチンに差し替えるドライバを組み込んでください
(HIOCS PLUS version 1.10+16.17以降など)。


## ioctrl12
コマンドライン引数で指定したファイルを読み込みオープンし、`DOS _IOCTRL (MD=12, F_CODE=0)`
でファイルの特殊コントロールを行います。  
ファイル名を省略した場合は標準入力(ファイルハンドル0)に対して実行します。

Human68k version 3.02ではキャラクタデバイスが特殊IOコントロールに対応しているか
調べずにデバイスドライバを呼び出しているため、対応していないデバイスに対して
実行するとアドレスエラー等が発生する場合があります。


## ioctrl13
コマンドライン引数で指定したドライブ(省略時はカレントドライブ)に対して
`DOS _IOCTRL (MD=13, F_CODE=0)`でドライブの特殊コントロールを行います。


## isemu_rtc
RTCの挙動の違いを利用して、実行環境が実機かエミュレータかを判別します。
エミュレータはバージョン検出ポートとWINDRVを無効にしたXM6gが対象です。
